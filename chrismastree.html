<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: relative; z-index: 1; }
        
        #video-input {
            position: absolute; top: 20px; left: 20px;
            width: 160px; height: 120px;
            border-radius: 8px; opacity: 0.3;
            transform: scaleX(-1); z-index: 50;
            border: 1px solid rgba(255,255,255,0.2);
            display: none; 
        }

        #ui-layer {
            position: absolute; bottom: 40px; left: 50%;
            transform: translateX(-50%); z-index: 20;
            text-align: center; pointer-events: none; width: 100%;
        }

        .hud-text {
            color: rgba(255,255,255,0.8); font-size: 14px; letter-spacing: 1px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 24px; border-radius: 20px;
            display: inline-block;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* ç¥ç¦è¯­å®¹å™¨ */
        #greeting-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1); /* å¼¹æ€§è¿‡æ¸¡ */
            text-align: center;
        }

        .greeting-text {
            font-family: "Microsoft YaHei", sans-serif;
            font-size: 90px;
            font-weight: 900;
            color: #fff;
            /* å¤šå±‚å‘å…‰é˜´å½± */
            text-shadow: 
                0 0 10px #FFD700,
                0 0 30px #FFD700,
                0 0 60px #FF4500;
            letter-spacing: 8px;
            animation: floatText 4s ease-in-out infinite;
        }

        .sub-text {
            font-size: 20px; color: #FFE082; margin-top: 5px; opacity: 0.9;
            letter-spacing: 4px; font-weight: 300; text-transform: uppercase;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 16px; z-index: 50; text-align: center;
        }
    </style>
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨æŒ‚èµ·æ˜Ÿæ˜Ÿ...<br><span style="font-size:12px; opacity:0.6">è¯·å…è®¸æ‘„åƒå¤´è®¿é—®</span></div>
    
    <div id="greeting-container">
        <div class="greeting-text">å«å«åœ£è¯å¿«ä¹</div>
        <div class="sub-text">Merry Christmas</div>
    </div>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-text">
            ğŸ‘‹ å•æ‰‹ï¼šæ§åˆ¶ç²’å­ | ğŸ™Œ åŒæ‰‹ï¼šæœ‰æƒŠå–œå“¦
        </div>
    </div>

    <script type="module">
        // ==========================================
        // 1. å…¨å±€é…ç½®
        // ==========================================
        const state = {
            targetDispersion: 0.0,
            currentDispersion: 0.0,
            targetScale: 1.0,
            currentScale: 1.0,
            isEggActive: 0.0,
            currentEggFactor: 0.0
        };

        const PALETTE = {
            greenBase: new THREE.Color('#1a472a'),
            greenLight: new THREE.Color('#43a047'),
            snow: new THREE.Color('#e1f5fe'),
            trunk: new THREE.Color('#4e342e'),
            star: new THREE.Color('#ffc107'),
            ribbon: new THREE.Color('#fff9c4'),
            ornaments: [
                new THREE.Color('#f44336'), 
                new THREE.Color('#ffa726'), 
                new THREE.Color('#29b6f6')
            ]
        };

        // ==========================================
        // 2. Three.js åœºæ™¯
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#050509'); // ææ·±çš„è“é»‘è‰²

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 0, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // ==========================================
        // 3. æ¨¡å‹æ„å»º (ä¿æŒåŸæœ‰ç‚¹é˜µç»“æ„)
        // ==========================================
        function createMagicTree(count) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const randoms = [];
            const sphereDirs = []; 

            const center = new THREE.Vector3(0, 2, 0);

            const addParticle = (x, y, z, color, sizeBase) => {
                positions.push(x, y, z);
                colors.push(color.r, color.g, color.b);
                sizes.push(sizeBase * (0.8 + Math.random() * 0.6));
                randoms.push(Math.random());

                // é¢„è®¡ç®—å½’ä¸€åŒ–çš„çƒä½“æ–¹å‘å‘é‡
                const dir = new THREE.Vector3(x, y, z).sub(center).normalize();
                sphereDirs.push(dir.x, dir.y, dir.z);
            };

            // 1. æ ‘å¹²
            for (let i = 0; i < count * 0.08; i++) {
                const r = Math.random() * 1.8; 
                const theta = Math.random() * Math.PI * 2;
                const h = Math.random() * 8 - 14;
                const rSurf = Math.sqrt(Math.random()) * 2.0 + 0.5;
                addParticle(rSurf * Math.cos(theta), h, rSurf * Math.sin(theta), PALETTE.trunk, 1.2);
            }

            // 2. æ ‘å¶ (åˆ†å±‚)
            const layers = 4;
            const layerHeight = 6.5;
            const startY = -8;
            for (let l = 0; l < layers; l++) {
                const layerBaseY = startY + l * 4.5;
                const bottomR = 11 - l * 2.2;
                const topR = 3.5 - l * 0.8;
                const pCount = (count * 0.75) / layers;
                
                for (let i = 0; i < pCount; i++) {
                    const hRatio = Math.random();
                    const y = layerBaseY + hRatio * layerHeight;
                    const currentR = bottomR * (1.0 - hRatio) + topR * hRatio * 0.6;
                    const r = Math.sqrt(Math.random() * 0.3 + 0.7) * currentR;
                    const theta = Math.random() * Math.PI * 2;
                    
                    let col = PALETTE.greenBase;
                    let size = 2.0;

                    const isEdge = r > currentR * 0.9;
                    const isTop = hRatio > 0.9;
                    
                    if ((isEdge && Math.random() > 0.7) || (isTop && Math.random() > 0.5)) {
                        col = PALETTE.snow;
                        size = 1.6;
                    } else if (Math.random() > 0.75) {
                        col = PALETTE.greenLight;
                    }
                    
                    if (isEdge && Math.random() > 0.98) {
                        col = PALETTE.ornaments[Math.floor(Math.random() * PALETTE.ornaments.length)];
                        size = 4.0;
                    }

                    addParticle(r * Math.cos(theta), y, r * Math.sin(theta), col, size);
                }
            }

            // 3. ä¸å¸¦
            for (let i = 0; i < 800; i++) {
                const t = i / 800;
                const angle = t * Math.PI * 9;
                const radius = 3 + t * 9;
                const h = 13 - t * 23;
                const jx = (Math.random()-0.5), jy = (Math.random()-0.5);
                addParticle(
                    Math.cos(angle)*radius + jx, 
                    h + jy, 
                    Math.sin(angle)*radius, 
                    PALETTE.ribbon, 
                    1.7
                );
            }

            // 4. æ˜Ÿæ˜Ÿ
            for(let i=0; i<300; i++) {
                const r = 1.6 * Math.cbrt(Math.random()); 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                addParticle(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta) + 14.5,
                    r * Math.cos(phi),
                    PALETTE.star, 
                    2.2
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('sphereDir', new THREE.Float32BufferAttribute(sphereDirs, 3));
            geometry.setAttribute('random', new THREE.Float32BufferAttribute(randoms, 1));
            geometry.setAttribute('originalPos', new THREE.Float32BufferAttribute(positions, 3));

            return geometry;
        }

        // ==========================================
        // 4. Shader (æ ¸å¿ƒï¼šç¯ç»•ä¸é—ªçƒ)
        // ==========================================
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uScale: { value: 1.0 },
                uDispersion: { value: 0.0 }, 
                uEggFactor: { value: 0.0 }, 
            },
            vertexShader: `
                uniform float uTime;
                uniform float uScale;
                uniform float uDispersion;
                uniform float uEggFactor;
                
                attribute float size;
                attribute vec3 color;
                attribute vec3 originalPos;
                attribute vec3 sphereDir;
                attribute float random;

                varying vec3 vColor;
                varying float vFlash; // ä¼ é€’ç»™ Fragment çš„é—ªçƒå¼ºåº¦

                // 2D æ—‹è½¬çŸ©é˜µ
                mat2 rotate2d(float angle) {
                    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                }

                void main() {
                    // 1. åŸºç¡€å‘¼å¸ä½ç§» (é™æ­¢æ—¶ä¹Ÿæœ‰å¾®å¼±ç”Ÿå‘½æ„Ÿ)
                    vec3 pos = originalPos;
                    pos.y += sin(uTime * 2.0 + random * 10.0) * 0.05;

                    // 2. å½¢æ€è®¡ç®— (æ ‘ -> çƒ)
                    vec3 spherePos = sphereDir * (15.0 + random * 6.0); 
                    float mixRatio = clamp(uDispersion * (0.6 + 0.4 * uEggFactor), 0.0, 1.0);
                    vec3 targetPos = mix(originalPos, spherePos, mixRatio);
                    
                    // 3. æ‰©æ•£ä½ç§» (ç‚¸å¼€)
                    float flyDist = uDispersion * (8.0 + random * 12.0);
                    targetPos += sphereDir * flyDist;

                    // 4. === æ ¸å¿ƒï¼šç¼“æ…¢ç¯ç»•ç§»åŠ¨ (Orbit) ===
                    // åªæœ‰å½“ uDispersion > 0 æ—¶æ‰ç”Ÿæ•ˆ
                    if (uDispersion > 0.05) {
                        // åŸºç¡€é€Ÿåº¦ + éšæœºå·®å¼‚
                        // å½©è›‹æ¨¡å¼ä¸‹(uEggFactor=1)æ—‹è½¬æ›´æ˜æ˜¾
                        float orbitSpeed = (0.2 + 0.3 * uEggFactor) * uDispersion; 
                        
                        // æ ¹æ®é«˜åº¦ä¸åŒï¼Œæ—‹è½¬æ–¹å‘å¯ä»¥ç¨å¾®é”™å¼€ï¼Œåˆ¶é€ æ˜Ÿäº‘æ„Ÿ
                        float angle = uTime * orbitSpeed * (0.8 + 0.4 * random);
                        
                        // ç»• Y è½´æ—‹è½¬ (æ°´å¹³ç¯ç»•)
                        targetPos.xz = rotate2d(angle) * targetPos.xz;

                        // åŒæ—¶ä¹Ÿç¨å¾®åŠ ä¸€ç‚¹å‚ç›´æ–¹å‘çš„æµ®åŠ¨ï¼Œåƒè¤ç«è™«
                        targetPos.y += sin(uTime * 1.5 + random * 100.0) * uDispersion * 2.0;
                    }

                    // 5. å½©è›‹é¿è®©æ–‡å­— (Void Effect)
                    if (uEggFactor > 0.1) {
                        float dist = length(targetPos);
                        float minRadius = 13.0 * uEggFactor;
                        if (dist < minRadius) {
                            targetPos = normalize(targetPos) * minRadius;
                        }
                    }

                    // åº”ç”¨æ•´ä½“ç¼©æ”¾
                    targetPos *= uScale;

                    vec4 mvPosition = modelViewMatrix * vec4(targetPos, 1.0);
                    gl_PointSize = size * (450.0 / -mvPosition.z) * uScale;
                    gl_Position = projectionMatrix * mvPosition;

                    // === æ ¸å¿ƒï¼šé—ªçƒå€¼è®¡ç®— (Twinkle) ===
                    vColor = color;
                    
                    // åŸºç¡€ï¼šä¸é—ªçƒ
                    vFlash = 1.0; 

                    // å½“ç²’å­æ•£å¼€æ—¶ï¼Œå¼€å§‹é—ªçƒ
                    if (uDispersion > 0.1) {
                        // é¢‘ç‡ï¼š3.0ï¼Œç›¸ä½ï¼šéšæœº
                        float flashWave = sin(uTime * 4.0 + random * 50.0); // -1 ~ 1
                        // æ˜ å°„åˆ° 0.6 ~ 1.4 (å˜æš—å’Œå˜äº®)
                        float flashIntensity = 1.0 + flashWave * 0.4 * uDispersion;
                        vFlash = flashIntensity;
                    }
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vFlash; // æ¥æ”¶é—ªçƒå¼ºåº¦

                void main() {
                    vec2 center = gl_PointCoord - 0.5;
                    float dist = length(center);
                    
                    if (dist > 0.45) discard;

                    // å°†é—ªçƒå¼ºåº¦åº”ç”¨åˆ°é¢œè‰²ä¸Š
                    // vFlash > 1.0 å˜äº® (è¶‹å‘ç™½è‰²)ï¼Œ< 1.0 å˜æš—
                    vec3 finalColor = vColor * vFlash;

                    // ç®€å•çš„è‰²è°ƒæ˜ å°„ï¼Œé˜²æ­¢è¿‡æ›æ—¶é¢œè‰²æ€ªå¼‚ï¼Œä¿ç•™æ¼«ç”»æ„Ÿ
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            transparent: false,
            depthTest: true,
            depthWrite: true
        });

        const points = new THREE.Points(createMagicTree(13000), material);
        scene.add(points);

        // ==========================================
        // 5. æ‰‹åŠ¿äº¤äº’
        // ==========================================
        const videoElement = document.getElementById('video-input');
        const greetingDiv = document.getElementById('greeting-container');

        function getHandOpenness(landmarks) {
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let avgDist = 0;
            tips.forEach(idx => {
                const tip = landmarks[idx];
                avgDist += Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
            });
            avgDist /= 4;
            return Math.max(0, Math.min(1, (avgDist - 0.15) / 0.25));
        }

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            let handsFound = 0;
            let totalOpenness = 0;

            if (results.multiHandLandmarks) {
                handsFound = results.multiHandLandmarks.length;
                results.multiHandLandmarks.forEach(l => totalOpenness += getHandOpenness(l));
            }

            // é€»è¾‘å¤„ç†
            let isEgg = false;
            let rawDispersion = 0;

            if (handsFound > 0) {
                rawDispersion = totalOpenness / handsFound;
            }

            // åŒæ‰‹å½©è›‹åˆ¤å®š
            if (handsFound === 2) {
                const open1 = getHandOpenness(results.multiHandLandmarks[0]);
                const open2 = getHandOpenness(results.multiHandLandmarks[1]);
                
                // åŒæ‰‹éƒ½å¼ å¼€è§¦å‘
                if (open1 > 0.65 && open2 > 0.65) {
                    isEgg = true;
                }

                const h1 = results.multiHandLandmarks[0][0];
                const h2 = results.multiHandLandmarks[1][0];
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                
                let sRaw = (dist - 0.1) * 2.5;
                state.targetScale = Math.max(0.6, Math.min(2.0, sRaw + 0.6));
            } else {
                state.targetScale = 1.0;
            }

            if (isEgg) {
                state.isEggActive = 1.0;
                state.targetDispersion = 1.6; // ç‚¸å¼€èŒƒå›´æ›´å¤§
            } else {
                state.isEggActive = 0.0;
                state.targetDispersion = rawDispersion * 0.9;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // ==========================================
        // 6. åŠ¨ç”» Loop
        // ==========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // é˜»å°¼å¤„ç†
            const damp = 3.5 * dt;
            state.currentScale += (state.targetScale - state.currentScale) * damp;
            state.currentDispersion += (state.targetDispersion - state.currentDispersion) * damp;
            
            // å½©è›‹å› å­å¹³æ»‘ (æ…¢ä¸€ç‚¹)
            state.currentEggFactor += (state.isEggActive - state.currentEggFactor) * (2.0 * dt);

            // UI æ§åˆ¶
            if (state.currentEggFactor > 0.5) {
                greetingDiv.style.opacity = '1';
                greetingDiv.style.transform = 'translate(-50%, -50%) scale(1)';
            } else {
                greetingDiv.style.opacity = '0';
                greetingDiv.style.transform = 'translate(-50%, -50%) scale(0.6)';
            }

            // æ›´æ–° Uniforms
            material.uniforms.uTime.value = clock.getElapsedTime();
            material.uniforms.uScale.value = state.currentScale;
            material.uniforms.uDispersion.value = state.currentDispersion;
            material.uniforms.uEggFactor.value = state.currentEggFactor;

            // æ•´ä½“å±•ç¤ºæ—‹è½¬ (å½©è›‹æ—¶å› ä¸ºç²’å­è‡ªå·±åœ¨è½¬ï¼Œæ•´ä½“æ—‹è½¬å°±å¯ä»¥åœä¸‹æ¥æˆ–è€…å˜æ…¢)
            const baseRotSpeed = 0.15 * (1.0 - state.currentEggFactor * 0.9);
            points.rotation.y += baseRotSpeed * dt; 

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>