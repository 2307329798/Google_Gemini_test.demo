<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js ä¼˜é›…æ‰‹åŠ¿ç²’å­</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        
        #input_video { display: none; }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #00d2ff;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #ui-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.85); backdrop-filter: blur(12px);
            padding: 12px 30px; border-radius: 30px; border: 1px solid rgba(255, 255, 255, 0.15);
            display: flex; gap: 20px; align-items: center; z-index: 100;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            user-select: none;
        }

        .btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.3); color: white;
            padding: 8px 18px; border-radius: 20px; cursor: pointer; transition: all 0.3s ease;
            font-size: 14px; outline: none; white-space: nowrap; font-weight: 500;
        }
        .btn:hover { background: rgba(255,255,255,0.15); }
        .btn.active { background: #00d2ff; border-color: #00d2ff; color: #000; box-shadow: 0 0 15px rgba(0, 210, 255, 0.4); }

        .color-wrapper { display: flex; align-items: center; gap: 10px; color: rgba(255,255,255,0.9); font-size: 14px; }
        input[type="color"] {
            border: none; width: 30px; height: 30px; border-radius: 50%; overflow: hidden; cursor: pointer; padding: 0; background: none;
        }

        #status {
            position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.6);
            font-size: 14px; pointer-events: none; z-index: 50; text-shadow: 0 2px 4px black;
            background: rgba(0,0,0,0.6); padding: 8px 15px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1); transition: opacity 0.3s;
        }
        
        #camera-wrapper {
            position: absolute; top: 20px; right: 20px; width: 180px; height: 135px;
            border-radius: 12px; border: 2px solid rgba(255,255,255,0.1); 
            overflow: hidden; z-index: 50; background: #000; opacity: 0.9;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        #camera-preview {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">å¯åŠ¨è§†è§‰å¼•æ“...</div>
    </div>

    <video id="input_video" playsinline webkit-playsinline></video>
    
    <div id="camera-wrapper">
        <canvas id="camera-preview"></canvas>
    </div>

    <div id="status">ç­‰å¾…æ‰‹åŠ¿...</div>

    <div id="ui-panel">
        <button class="btn active" onclick="setShape('heart')">â¤ çˆ±å¿ƒ</button>
        <button class="btn" onclick="setShape('fireworks')">ğŸ† æ˜Ÿäº‘</button>
        
        <div class="color-wrapper">
            <span>ç²’å­é¢œè‰²</span>
            <input type="color" id="colorPicker" value="#ff0055">
        </div>

        <button class="btn" onclick="toggleFullScreen()">â›¶</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. Three.js åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40; // ç¨å¾®æ‹‰è¿œç›¸æœºï¼Œç»™æ”¾å¤§ç•™å‡ºç©ºé—´

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 2. ç²’å­åˆå§‹åŒ– ---
        const particleCount = 7000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const randomOffsets = new Float32Array(particleCount * 3);
        const shapes = { heart: [], fireworks: [] };
        const currentPositions = new Float32Array(particleCount * 3);

        const material = new THREE.PointsMaterial({
            color: 0xff0055,
            size: 0.3,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });
        
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        function initShapes() {
            for (let i = 0; i < particleCount; i++) {
                // é¢„è®¡ç®—æ‰©æ•£æ–¹å‘
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                randomOffsets[i*3] = Math.sin(phi) * Math.cos(theta);
                randomOffsets[i*3+1] = Math.sin(phi) * Math.sin(theta);
                randomOffsets[i*3+2] = Math.cos(phi);

                // 1. Fireworks (çƒä½“)
                const r = 10 + Math.random() * 3;
                shapes.fireworks.push(
                    r * randomOffsets[i*3],
                    r * randomOffsets[i*3+1],
                    r * randomOffsets[i*3+2]
                );

                // åˆå§‹åŒ–ä¸ºçƒä½“ä½ç½®
                positions[i*3] = shapes.fireworks[i*3];
                positions[i*3+1] = shapes.fireworks[i*3+1];
                positions[i*3+2] = shapes.fireworks[i*3+2];
                currentPositions[i*3] = positions[i*3];
                currentPositions[i*3+1] = positions[i*3+1];
                currentPositions[i*3+2] = positions[i*3+2];

                // 2. Heart
                const t = Math.random() * Math.PI * 2; 
                let hx = 16 * Math.pow(Math.sin(t), 3);
                let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let hz = (Math.random() - 0.5) * 5;
                const fill = Math.pow(Math.random(), 0.5); // ç¨å¾®å‘å¿ƒåˆ†å¸ƒ
                shapes.heart.push(hx * fill * 0.9, hy * fill * 0.9, hz * fill);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        }
        initShapes();

        // --- 3. äº¤äº’ä¸çŠ¶æ€ ---
        let currentShape = 'heart';
        let baseColor = new THREE.Color(0xff0055);
        
        // åŠ¨ç”»ç›®æ ‡å€¼
        let currentScale = 1.0;
        let targetScale = 1.0;
        let currentDispersion = 0.0;
        let targetDispersion = 0.0;
        
        window.setShape = (s) => {
            currentShape = s;
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };
        
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            baseColor.set(e.target.value);
        });
        
        window.toggleFullScreen = () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        };

        // --- 4. è§†è§‰ä¸AIå¤„ç† ---
        const videoElement = document.getElementById('input_video');
        const previewCanvas = document.getElementById('camera-preview');
        const previewCtx = previewCanvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const loader = document.getElementById('loader');

        let isAiBusy = false; 
        let lastAiTime = 0;

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 0,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            isAiBusy = false; 

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                let rawFactor = 0; // 0.0 ~ 1.0

                if (results.multiHandLandmarks.length === 2) {
                    const p1 = results.multiHandLandmarks[0][0];
                    const p2 = results.multiHandLandmarks[1][0];
                    const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                    
                    // è°ƒæ•´æ„Ÿåº”èŒƒå›´ï¼šå¿½ç•¥è¿‡è¿‘çš„å¾®å°æŠ–åŠ¨
                    // åªæœ‰å½“è·ç¦»å¤§äº 0.18 (æ‰‹å¼€å§‹çœŸæ­£åˆ†å¼€) æ—¶æ‰å¼€å§‹è®¡ç®—
                    rawFactor = (dist - 0.18) / 0.5; 
                    statusDiv.innerHTML = `åŒæ‰‹æ§åˆ¶æ¨¡å¼ <span style="color:#00d2ff">â—</span>`;
                } else {
                    const h = results.multiHandLandmarks[0];
                    const dist = Math.sqrt(Math.pow(h[4].x - h[8].x, 2) + Math.pow(h[4].y - h[8].y, 2));
                    rawFactor = (dist - 0.03) / 0.18;
                    statusDiv.innerHTML = `å•æ‰‹æ§åˆ¶æ¨¡å¼ <span style="color:#00d2ff">â—</span>`;
                }

                // é™åˆ¶åœ¨ 0-1 ä¹‹é—´
                rawFactor = Math.max(0, Math.min(1, rawFactor));

                // === å…³é”®ä¿®æ”¹ï¼šéçº¿æ€§æ˜ å°„ (Easing) ===
                // ä½¿ç”¨å¹³æ–¹å‡½æ•°ï¼šå½“æ‰‹å¼ å¼€åº¦è¾ƒå°æ—¶(å¦‚0.2)ï¼Œç»“æœéå¸¸å°(0.04)
                // åªæœ‰å½“æ‰‹å¼ å¼€åº¦è¾ƒå¤§æ—¶ï¼Œæ•°å€¼æ‰ä¼šè¿…é€Ÿä¸Šå‡
                // è¿™å®ç°äº†â€œåˆšå¼€å§‹å¼ å¼€æ—¶å¹³ç¼“ï¼Œåé¢æ‰å‰§çƒˆâ€çš„æ•ˆæœ
                const easedFactor = Math.pow(rawFactor, 2.0); 

                // æ˜ å°„åˆ°ç›®æ ‡å±æ€§
                targetScale = 0.8 + (easedFactor * 1.5); // 0.8x åˆ° 2.3x
                targetDispersion = Math.pow(rawFactor, 3.0) * 18.0; // æ‰©æ•£ä¹Ÿä½¿ç”¨æ›´ç¼“çš„æ›²çº¿

            } else {
                statusDiv.innerHTML = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
                // å¾…æœºå‘¼å¸åŠ¨ç”»
                const time = Date.now() * 0.0015;
                targetScale = 1.0 + Math.sin(time) * 0.1; 
                targetDispersion = 0; 
            }
        });

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480, facingMode: "user" } 
                });
                videoElement.srcObject = stream;
                await videoElement.play();
                loader.style.opacity = 0;
                setTimeout(() => { loader.style.display = 'none'; }, 500);
                previewCanvas.width = 320;
                previewCanvas.height = 240;
                processVideoLoop();
            } catch (err) {
                console.error(err);
                document.getElementById('loader-text').innerText = "æ— æ‘„åƒå¤´æƒé™";
            }
        }

        function processVideoLoop() {
            if (videoElement.readyState === 4) {
                previewCtx.drawImage(videoElement, 0, 0, previewCanvas.width, previewCanvas.height);
                const now = Date.now();
                if (!isAiBusy && (now - lastAiTime > 40)) { // é™åˆ¶çº¦ 25fps å¤„ç†ï¼Œç•™æ›´å¤šèµ„æºç»™æ¸²æŸ“å¹³æ»‘
                    isAiBusy = true;
                    lastAiTime = now;
                    hands.send({image: videoElement}).catch(() => isAiBusy = false);
                }
            }
            requestAnimationFrame(processVideoLoop);
        }

        // --- 5. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // === å…³é”®ä¿®æ”¹ï¼šå¹³æ»‘æ’å€¼ç³»æ•° ===
            // ä¹‹å‰çš„ 0.2 æ”¹ä¸º 0.05
            // æ„å‘³ç€æ¯ä¸€å¸§åªå‘ç›®æ ‡ç§»åŠ¨ 5%ï¼Œè¿™ä¼šäº§ç”Ÿæ˜æ˜¾çš„â€œé‡é‡æ„Ÿâ€å’Œæƒ¯æ€§
            // æ— è®ºæ‰‹éƒ¨æ•°æ®å¦‚ä½•æŠ–åŠ¨ï¼Œç”»é¢éƒ½ä¼šåƒæ¶²ä½“ä¸€æ ·å¹³æ»‘
            currentScale += (targetScale - currentScale) * 0.05;
            
            // æ‰©æ•£ç¨å¿«ä¸€ç‚¹ç‚¹ï¼Œä¿è¯è§†è§‰åé¦ˆ
            currentDispersion += (targetDispersion - currentDispersion) * 0.08;

            // é¢œè‰²åŠ¨æ€é€»è¾‘
            const colorIntensity = Math.min(currentDispersion / 15, 1);
            material.color.lerpColors(baseColor, new THREE.Color(0xffffff), colorIntensity * 0.6); // ç™½è‰²æ··åˆé™ä½ä¸€ç‚¹

            const targetData = shapes[currentShape];
            const posArr = geometry.attributes.position.array;
            const time = Date.now() * 0.001;

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // å½¢çŠ¶å˜æ¢æ’å€¼
                currentPositions[ix] += (targetData[ix] - currentPositions[ix]) * 0.08;
                currentPositions[iy] += (targetData[iy] - currentPositions[iy]) * 0.08;
                currentPositions[iz] += (targetData[iz] - currentPositions[iz]) * 0.08;

                // æ‰©æ•£å‘é‡
                const dx = randomOffsets[ix] * currentDispersion;
                const dy = randomOffsets[iy] * currentDispersion;
                const dz = randomOffsets[iz] * currentDispersion;

                // å™ªç‚¹
                const nx = Math.sin(time * 1.5 + i * 0.1) * (0.05 + currentDispersion * 0.02);
                const ny = Math.cos(time * 1.2 + i * 0.2) * (0.05 + currentDispersion * 0.02);
                const nz = Math.sin(time + i * 0.3) * (0.05 + currentDispersion * 0.02);

                // ç»„åˆï¼š(å½¢çŠ¶ä½ç½® * ç¼©æ”¾) + æ‰©æ•£ + å™ªç‚¹
                posArr[ix] = currentPositions[ix] * currentScale + dx + nx;
                posArr[iy] = currentPositions[iy] * currentScale + dy + ny;
                posArr[iz] = currentPositions[iz] * currentScale + dz + nz;
            }

            geometry.attributes.position.needsUpdate = true;
            
            // ä¼˜é›…çš„æ—‹è½¬
            particles.rotation.y += 0.001 + (currentDispersion * 0.0005);
            particles.rotation.z = Math.sin(time * 0.5) * 0.05; // è½»å¾®æ‘†åŠ¨
            
            renderer.render(scene, camera);
        }

        startCamera();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>